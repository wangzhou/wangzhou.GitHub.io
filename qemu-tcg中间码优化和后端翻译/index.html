<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangzhou.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文介绍qemu tcg下中间码翻译和后端翻译的基本逻辑，代码分析基于qemu v7.1.50， 文中涉及的测试场景，我们选择riscv作为guest、arm64作为host。">
<meta property="og:type" content="article">
<meta property="og:title" content="qemu tcg中间码优化和后端翻译">
<meta property="og:url" content="http://wangzhou.github.io/qemu-tcg%E4%B8%AD%E9%97%B4%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E5%90%8E%E7%AB%AF%E7%BF%BB%E8%AF%91/index.html">
<meta property="og:site_name" content="Sherlock&#39;s blog">
<meta property="og:description" content="本文介绍qemu tcg下中间码翻译和后端翻译的基本逻辑，代码分析基于qemu v7.1.50， 文中涉及的测试场景，我们选择riscv作为guest、arm64作为host。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-15T14:22:00.000Z">
<meta property="article:modified_time" content="2023-04-13T01:09:41.359Z">
<meta property="article:author" content="Sherlock Wang">
<meta property="article:tag" content="QEMU">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wangzhou.github.io/qemu-tcg%E4%B8%AD%E9%97%B4%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E5%90%8E%E7%AB%AF%E7%BF%BB%E8%AF%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>qemu tcg中间码优化和后端翻译 | Sherlock's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sherlock's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">宗教般的信仰，初恋般的热情</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">87</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">214</span></a>

  </li>
        <li class="menu-item menu-item-reprint">

    <a href="/reprint" rel="section"><i class="fa fa-archive fa-fw"></i>转载</a>

  </li>
        <li class="menu-item menu-item-read">

    <a href="/categories/read" rel="section"><i class="fa fa-th fa-fw"></i>读书笔记</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wangzhou.github.io/qemu-tcg%E4%B8%AD%E9%97%B4%E7%A0%81%E4%BC%98%E5%8C%96%E5%92%8C%E5%90%8E%E7%AB%AF%E7%BF%BB%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/yase.svg">
      <meta itemprop="name" content="Sherlock Wang">
      <meta itemprop="description" content="Linux, kernel, 计算机体系结构">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sherlock's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          qemu tcg中间码优化和后端翻译
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-15 22:22:00" itemprop="dateCreated datePublished" datetime="2023-03-15T22:22:00+08:00">2023-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-13 09:09:41" itemprop="dateModified" datetime="2023-04-13T09:09:41+08:00">2023-04-13</time>
              </span>

          
            <div class="post-description">本文介绍qemu tcg下中间码翻译和后端翻译的基本逻辑，代码分析基于qemu v7.1.50， 文中涉及的测试场景，我们选择riscv作为guest、arm64作为host。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="基本逻辑"><a href="#基本逻辑" class="headerlink" title="基本逻辑"></a>基本逻辑</h2><p> qemu tcg的基本翻译思路是把guest指令先翻译成中间码(IR)，然后再把IR翻译成host指令。<br> guest-&gt;IR-&gt;host这种三段式实现的好处是把前端翻译，优化和后端翻译拆开了，降低了开发<br> 的难度，比如，要模拟一个新构架的CPU，只要实现guest-&gt;IR这一步就好，后续在X86或者在<br> ARM64的host的机器上跑，重新编译下qemu就好，并不用去熟悉host CPU的构架。</p>
<p> guest翻译成IR的逻辑在<a href="%5Bhttps://wangzhou.github.io/qemu-tcg%E7%BF%BB%E8%AF%91%E6%89%A7%E8%A1%8C%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90/">这里</a>已经有介绍，这一步主要靠程序员手写代码生成IR，本文主<br> 要讲中间码的优化和后端翻译，我们可以认为这两部分属于翻译IR到host指令，为了看清楚<br> IR到host指令的翻译，我们首先要明确前端翻译得到的IR是怎么样的。</p>
<p> IR指令的理解是比较直白的，qemu定义了一套IR的指令，具体的定义在tcg/README里说明,<br> 在一个tb里，qemu前端翻译得到的IR被串联到一个链表里，中间码优化和后端翻译都靠这个<br> 链表得到IR，中间码优化时，需要改动IR时(比如，删掉不可达的IR)，对这个链表做操作就<br> 好。</p>
<p> 中间码不只是定义了对应的指令，也有寄存器的定义，它形成了一个独立的逻辑空间，在IR<br> 这一层，可以认为都在中间码相关的寄存器上做计算的。IR这一层定义了几个寄存器类型，<br> 它们分别是：global, local temp, normal temp, fixed, const, ebb</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef enum TCGTempKind &#123;                                                      </span><br><span class="line">    /* Temp is dead at the end of all basic blocks. */                          </span><br><span class="line">    TEMP_NORMAL,                                                                </span><br><span class="line">    /* Temp is live across conditional branch, but dead otherwise. */           </span><br><span class="line">    TEMP_EBB,                                                                   </span><br><span class="line">    /* Temp is saved across basic blocks but dead at the end of TBs. */         </span><br><span class="line">    TEMP_LOCAL,                                                                 </span><br><span class="line">    /* Temp is saved across both basic blocks and translation blocks. */        </span><br><span class="line">    TEMP_GLOBAL,                                                                </span><br><span class="line">    /* Temp is in a fixed register. */                                          </span><br><span class="line">    TEMP_FIXED,                                                                 </span><br><span class="line">    /* Temp is a fixed constant. */                                             </span><br><span class="line">    TEMP_CONST,                                                                 </span><br><span class="line">&#125; TCGTempKind;                                                                  </span><br></pre></td></tr></table></figure>
<p> 一般guest的gpr也被定义为IR这一层的global寄存器，中间码做计算的时候，会用到一些<br> 临时变量，这些临时变量就保存在local temp或者是normal temp这样的寄存器里，计算的<br> 时候要用到一些常量时，需要定义一个TCG寄存器，创建一个常量并把它赋给TCG寄存器。</p>
<p> global、local temp、normal temp和const这些TCG寄存器我们在写前端翻译的时候会经常<br> 用到，fixed和ebb直接用到的情况不多。</p>
<p> TCG寄存器是怎么定义和被使用的，以及它们本质上是什么？我们基于riscv看下这个问题。<br> riscv下global寄存器一般如下定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* target/riscv/translate.c */</span><br><span class="line">riscv_translate_init</span><br><span class="line">  [...]</span><br><span class="line">  +-&gt; cpu_gpr[i] = tcg_global_mem_new(cpu_env, </span><br><span class="line">  		    offsetof(CPURISCVState, gpr[i]), riscv_int_regnames[i]);            </span><br><span class="line">        /* 在TCGContext里分配对应的空间，并且设定这个寄存器是TEMP_GLOBAL */</span><br><span class="line">    +-&gt; tcg_global_mem_new_internal(..., reg, offset, name);  </span><br><span class="line">  [...]</span><br><span class="line">  +-&gt; cpu_pc = tcg_global_mem_new(cpu_env, offsetof(CPURISCVState, pc), &quot;pc&quot;);    </span><br><span class="line">  [...]</span><br></pre></td></tr></table></figure>
<p> 我们只挑了gpr和pc的这几行代码出来，这里分配了对应的TCG寄存器，返回值是这些寄存器<br> 存储地址相对tcg_ctx的偏移。注意这里得到的是global寄存器的描述结构，类型是TCGTemp，<br> 而global寄存器实际存储在CPURISCVState内具体定义的地方，TCGTemp内通过mem_base和<br> mem_offset指向具体存储地址。</p>
<p> 实际上，所有TCG寄存器的分配都是在TCGContext里分配了对应的存储空间，并且配置上相关<br> 参数，这些参数和IR一起交给后端做IR优化和后端翻译，后端使用TCGContext的地址和具体<br> 寄存器的偏移可以找见具体的TCG寄存器。</p>
<p> local temp和normal temp的说明在<a href="https://wangzhou.github.io/qemu%E4%B8%ADbasic-block%E4%BB%A5%E5%8F%8Atcg%E4%B8%AD%E5%90%84%E7%A7%8D%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91">这里</a>有说明。简而言之，normal temp只在一个BB中有效，<br> local temp在一个TB中有效。</p>
<p> fixed要结合host寄存器分配来看，首先IR中分配的这些寄存器都是虚拟的寄存器，IR翻译<br> 到host指令都要给虚拟寄存器分配对应的host物理寄存器，当一个TCG寄存器有TEMP_FIXED<br> 标记表示在后端翻译时把这个虚拟寄存器固定映射到一个host物理寄存器上，一般fixed寄<br> 存器都是翻译执行时经常要用到的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* tcg/tcg.c */</span><br><span class="line">tcg_context_init</span><br><span class="line">  /*</span><br><span class="line">   * 在tcg后端公共逻辑里，定义一个TCG寄存器，并把它绑定到host的TCG_AREG0这个寄存器上</span><br><span class="line">   * 每个host都会把具体的实际物理寄存器映射到TCG_AREG0。</span><br><span class="line">   */</span><br><span class="line">  +-&gt; ts = tcg_global_reg_new_internal(s, TCG_TYPE_PTR, TCG_AREG0, &quot;env&quot;);        </span><br><span class="line">  +-&gt; cpu_env = temp_tcgv_ptr(ts);                                                </span><br></pre></td></tr></table></figure>
<p> 如上的cpu_env依然是cpu_env寄存器存储地址针对tcg_ctx的偏移，前端翻译代码里会大量<br> 的用到cpu_env这个值，所以这里把它定义成fixed寄存器，提示后端翻译把cpu_env的值固定<br> 的放到一个host寄存器里。具体看，tcg_global_reg_new_internal里会把被绑定的host物理<br> 寄存器放到reserved_regs集合，这样，后端翻译后续就不会分配这个物理寄存器，cpu_env<br> 保存的是guest CPU软件结构体的指针，那么这个指针又是怎么传递给reserved TCG_AREG0<br> host物理寄存器？可以看到一个tb执行的时候这个指针作为第一个入参传递给tb里生成的<br> host指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpu_exec</span><br><span class="line">  +-&gt; cpu_loop_exec_tb</span><br><span class="line">    +-&gt; cpu_tb_exec(cpu, ...)</span><br><span class="line">      +-&gt; tcg_qemu_tb_exec(env, ...)</span><br></pre></td></tr></table></figure>
<p> 在tb头里，会有一条指令把这个入参送给TCG_AREG0(ARM64的x19)，我们看看ARM64作为后端<br> 时，这个代码生成的逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* tcg/aarch64/tcg-target.c.inc */</span><br><span class="line">tcg_target_qemu_prologue</span><br><span class="line">  [...]</span><br><span class="line">  +-&gt; tcg_set_frame(s, TCG_REG_SP, TCG_STATIC_CALL_ARGS_SIZE, CPU_TEMP_BUF_NLONGS * sizeof(long));</span><br><span class="line">    +-&gt; tcg_global_reg_new_internal(s, TCG_TYPE_PTR, reg, &quot;_frame&quot;);          </span><br><span class="line">  [...]</span><br><span class="line">  +-&gt; tcg_out_mov(s, TCG_TYPE_PTR, TCG_AREG0, tcg_target_call_iarg_regs[0]);      </span><br></pre></td></tr></table></figure>
<p> 如上，公共代码里还会把host的栈寄存器也reserv出来做特定的用途，这里sp就是host上<br> sp自己的语意，因为host调用翻译好的host指令，就是一个host上的函数调用。</p>
<p> ebb类型的TCG寄存器表示这个寄存器可以跨越条件跳转，但是跨越之后状态为dead，这种<br> 变量类型和indirect的global寄存器有关系，在liveness_pass_2中会为indirect的global<br> 寄存器新创建ebb类型的TCG寄存器，具体用法还待分析。</p>
<p> (todo: 具体用法)</p>
<h2 id="中间码优化"><a href="#中间码优化" class="headerlink" title="中间码优化"></a>中间码优化</h2><p> 前端翻译得到的IR可能会有优化的空间存在，所以qemu在进行后端翻译之前会先做中间码<br> 优化，优化以一个TB为单位，优化的输入就是一个TB对应的IR和用到的TCG寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* tcg/tcg.c */</span><br><span class="line">tcg_gen_code</span><br><span class="line">  +-&gt; tcg_optimize(s)</span><br><span class="line">    +-&gt; done = fold_add(&amp;ctx, op);                                          </span><br><span class="line"></span><br><span class="line">  +-&gt; reachable_code_pass(s);                                                     </span><br></pre></td></tr></table></figure>
<p> tcg_optimize是做着一些常量的检查，进而做指令优化(折叠常量表达式), 我们取其中的<br> 一个case，比如fold_add具体看下，大概知道下这里是在干什么。可以看到这个case检测<br> add_32/64这个IR的两个操作数是不是常量，如果是常量，那么在这里直接把常量相加后的<br> 结果放到一个常量类型TCG寄存器，然后把之前的add_32/64改成一条mov指令。</p>
<p> 从名字就可以看出reachable_code_pass应该做的是一些死代码的删除，这里检测到运行不到<br> 的IR就直接从IR链表里把他们删掉。</p>
<p> 中间码优化的输出还是IR链表和相关的TCG寄存器，可见我们也可以把这两个函数注释掉，<br> 从而把中间码优化关掉。可以看出，中间码优化和编译器IR优化的逻辑是类似的。</p>
<p> 中间码优化的具体case本文就不继续展开了，后续有需要再写吧。</p>
<h2 id="寄存器活性分析"><a href="#寄存器活性分析" class="headerlink" title="寄存器活性分析"></a>寄存器活性分析</h2><p> qemu最终还是要把IR和TCG寄存器翻译成host指令和host寄存器，才能在host机器上运行,<br> 这一节和下一节就是要解决这个问题。直观来看，IR和host指令大概是可以对应上的，这里<br> 要解决的关键问题就是怎么把虚拟级的TCG寄存器映射到host物理寄存器上。</p>
<p> 我们先看下具体的两条riscv指令是怎么翻译成host指令的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">riscv guest汇编:</span><br><span class="line"></span><br><span class="line">  0x0000000000010172:  1101              addi            sp,sp,-32</span><br><span class="line">  0x0000000000010174:  ec06              sd              ra,24(sp)</span><br><span class="line"></span><br><span class="line">中间码：</span><br><span class="line"></span><br><span class="line">  ---- 0000000000010172 0000000000000000</span><br><span class="line">  add_i64 x2/sp,x2/sp,$0xffffffffffffffe0</span><br><span class="line">  </span><br><span class="line">  ---- 0000000000010174 0000000000000000</span><br><span class="line">  add_i64 tmp4,x2/sp,$0x18</span><br><span class="line">  qemu_st_i64 x1/ra,tmp4,leq,0</span><br><span class="line"></span><br><span class="line">ARM64 host汇编：</span><br><span class="line"></span><br><span class="line">    -- guest addr 0x0000000000010172 + tb prologue</span><br><span class="line">  0xffff9c000140:  b85f8274  ldur     w20, [x19, #-8]</span><br><span class="line">  0xffff9c000144:  7100029f  cmp      w20, #0</span><br><span class="line">  0xffff9c000148:  5400064b  b.lt     #0xffff9c000210</span><br><span class="line">  0xffff9c00014c:  f9400a74  ldr      x20, [x19, #0x10]</span><br><span class="line">  0xffff9c000150:  d1008294  sub      x20, x20, #0x20</span><br><span class="line">  0xffff9c000154:  f9000a74  str      x20, [x19, #0x10]</span><br><span class="line">    -- guest addr 0x0000000000010174</span><br><span class="line">  0xffff9c000158:  91006295  add      x21, x20, #0x18</span><br><span class="line">  0xffff9c00015c:  f9400676  ldr      x22, [x19, #8]</span><br><span class="line">  0xffff9c000160:  f83f6ab6  str      x22, [x21, xzr]</span><br></pre></td></tr></table></figure>
<p> riscv的addi被翻译成中间码add_i64, 注意中间码中的x2/sp是TEMP_GLOBAL类型的TCG寄存器，<br> riscv的sd指令被翻译成两条中间码，第一个中间码计算store的地址，并存在tmp4里，第二个<br> 中间码把ra寄存器的值保存到tmp4指向的地址。</p>
<p> 我们看下实际翻译出来的ARM64指令，第一条指令合并了一点tb头的指令，addi对应的host<br> 指令是从0xffff9c00014c这里开始的，从上面知道x19就是cpu_env的指针，0x10是riscv sp<br> 对应的TCG寄存器在cpu_env的偏移，所以“ldr x20, [x19, #0x10]”就是把保存在内存里的<br> guest CPU sp的值load到host寄存器x20上，下面sub指令对应的就是riscv的addi指令，然后<br> 紧接着一个str指令把sp的值更新回cpu_env，注意x20还是sp的值，所以, host还是可以使用<br> x20中保存的sp计算指令“sd ra,24(sp)”中sd要保存值的地址，翻译到host上的“add x21, x20, #0x18”，<br> x21保存sd要保存值的地址，后面的“ldr x22, [x19, #8]”同样把riscv的ra load到host寄存器<br> x22上，最后host使用“str x22, [x21, xzr]”完成“sd ra,24(sp)”的模拟。</p>
<p> 需要注意的是，如上的log是用qemu的user mode下得到的，user mode没有地址翻译，所以<br> store的模拟才会如此直接。如上的host寄存器对应的TCG寄存器类型: x19是fixed，x20/x22<br> 是global，x21是temp。寄存器如何分配、分配出的host寄存器什么时候可以重复利用、host<br> 寄存器上的值什么时候需要保存回cpu_env，这些都是活性分析和后端翻译要考虑的问题。</p>
<p> 寄存器活性分析代码主体逻辑如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tcg_gen_code</span><br><span class="line">  +-&gt; liveness_pass_1(s);                                                         </span><br><span class="line">  /*</span><br><span class="line">   * nb_indirects的值在创建global TCG寄存器的时候更新: tcg_global_mem_new_internal，</span><br><span class="line">   * 这个函数会检测base入参的TCG类型，注意不是自己的TCG类型，如果base的类型是global</span><br><span class="line">   * 才会增加nb_indirects的计数。一般调用这个函数为guest gpr创建global TCG寄存器</span><br><span class="line">   * 都是用cpu_env作为base入参，所以nb_indirects的值都不会增加。</span><br><span class="line">   *</span><br><span class="line">   * 也就是qemu认为，对于global虚拟寄存器的访问，如果是通过一个fix寄存器作为指针</span><br><span class="line">   * 访问，就叫direct，但是如果不是，就叫indirect。针对indirect的访问需要进行额外</span><br><span class="line">   * 的liveness_pass_2优化。</span><br><span class="line">   *</span><br><span class="line">   * 目前还有没有想到需要liveness_pass_2优化的例子。</span><br><span class="line">   */</span><br><span class="line">  +-&gt; if (s-&gt;nb_indirects &gt; 0) &#123;</span><br><span class="line">          if (liveness_pass_2(s)) &#123;                                               </span><br><span class="line">              liveness_pass_1(s);                                                 </span><br><span class="line">          &#125;                                                                       </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p> 如上，我们目前先分析liveness_pass_1的逻辑，IR和TCG寄存器的数据结构大概是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">tcg_ctx:</span><br><span class="line">        +--------+---------+---------+---------+---------+</span><br><span class="line">        | temp0  |  temp1  |  temp2  |  temp3  |  temp4  |</span><br><span class="line">        +--------+---------+---------+---------+---------+</span><br><span class="line">           ^        ^                   ^           ^</span><br><span class="line">TB ops:    |        +----------------+  |           |</span><br><span class="line">           +-------------+-------+   |  +--------+  |                 </span><br><span class="line">                         |    +--+---+-----------+--+                ^</span><br><span class="line">                         |    |  |   |           |                   |</span><br><span class="line">        +----------------+----+--+---+-----------+----------------+  |</span><br><span class="line">        | +-----+      +-+--+ |  | +-+--+      +-+--+             |  |</span><br><span class="line">        | |insn0|      |arg0| |  | |arg1|      |arg2|        life |  |  parse insn</span><br><span class="line">        | +-----+      +----+ |  | +----+      +----+             |  |</span><br><span class="line">        +---------------------+--+--------------------------------+  |</span><br><span class="line">        +---------------------+--+--------------------------------+  |</span><br><span class="line">        | +-----+      +----+ |  | +----+                         |  |</span><br><span class="line">        | |insn1|      |arg0+-+  +-+arg1|                    life |  |</span><br><span class="line">        | +-----+      +----+      +----+                         |  |</span><br><span class="line">        +---------------------------------------------------------+  |</span><br><span class="line">          ...                                                        |</span><br></pre></td></tr></table></figure>
<p> 如上所示，前端翻译生成的IR组成一个IR链表，每个IR节点里有它自己的寄存器定义和life，<br> 这个life标记当前IR中每个寄存器的状态。IR中的每个TCG变量指向tcg_ctx中TCG变量的实际<br> 保存地址，活性分析对于TB中的IR，按照<strong>逆序</strong>逐个分析对应的IR和IR的TCG寄存器的状态，<br> 分析过程把TCG寄存器的状态动态的更新到tcg_ctx的TCG寄存器对象中，位置相对在上面的<br> IR的TCG寄存器状态受下面IR的TCG寄存器状态的影响，而下面的TCG寄存器状态在分析的时候<br> 已经更新到tcg_ctx的TCG寄存器对象中，每条IR的寄存器分析完后的静态状态保存在op-&gt;life<br> 里。</p>
<p> TCG寄存器的状态有两种，分别是TS_DEAD和TS_MEM，TS_DEAD的寄存器表示这个寄存器不会<br> 被后续(顺序)的指令使用，TS_MEM的表示寄存器需要向内存同步。</p>
<p> TCG寄存器在遍历开始的初始值是：global变量是TS_DEAD | TS_MEM, 其它是TS_DEAD。所有<br> global变量，比如gpr，都要刷回内存，其它的变量都是临时变量(cpu_env，sp也不需要刷会<br> 内存)，先都配置成dead，如果后续检测到寄存器之间存在依赖，再配置成live(我们把dead<br> 这个状态被去掉，认为TCG寄存器变成live状态)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IR0: add temp2, temp4, temp5</span><br><span class="line">IR1: add temp1, temp2, temp3</span><br></pre></td></tr></table></figure>
<p> 用如上的两个IR举个例子，qemu从IR1开始分析，IR1的temp1/temp2/temp3都会配置成dead，<br> 因为后续没有指令，也就没有指令会使用，分析IR0时，qemu会检测到temp2在IR1里会使用，<br> 就会把IR0对应的temp2配置成live。可以看到寄存器dead/live的状态是针对具体指令的，<br> 寄存器dead/live状态会直接影响到后续host寄存器的分配，分配寄存器的时候，当一个虚拟<br> 寄存器是dead时，它后续不会被用，qemu就可以把这个虚拟寄存器对应的host寄存器重新分配<br> 使用，反之不行。</p>
<p> liveness_pass_1的逻辑大概是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">liveness_pass_1</span><br><span class="line">  /* 遍历开始，更新TCG寄存器为初始状态 */</span><br><span class="line">  la_func_end(s, nb_globals, nb_temps);                                       </span><br><span class="line">  /*</span><br><span class="line">   * 逆序遍历TB的中间码链表，除了几种类型的中间码要特殊处理下，剩余的都在默认</span><br><span class="line">   * 处理分支里(default)。需要单独处理的中间码有：call、insn_start、discard、</span><br><span class="line">   * 多输出的中间码(add2/sub2/mulu2/muls2_i32/i64)。</span><br><span class="line">   *</span><br><span class="line">   * 我们先关注default流程，然后再看需要单独处理的中间码。</span><br><span class="line">   */</span><br><span class="line">  QTAILQ_FOREACH_REVERSE_SAFE(op, &amp;s-&gt;ops, link, op_prev)</span><br><span class="line">  /* </span><br><span class="line">   * 如下是switch中的default的逻辑。</span><br><span class="line">   *</span><br><span class="line">   * 对于不是side_effect的指令，只要有输出参数不是dead，就不能去掉这条指令，否则</span><br><span class="line">   * 所有输出参数都dead了，这个指令就可以去掉了。</span><br><span class="line">   */</span><br><span class="line">  do_remove:</span><br><span class="line">    +-&gt; tcg_op_remove(s, op);                                               </span><br><span class="line"></span><br><span class="line">  /* 寄存器活性分析核心逻辑在这里 */</span><br><span class="line">  do_not_remove:</span><br><span class="line">    /*</span><br><span class="line">     * 首先处理IR的输出寄存器，根据TCG寄存器状态更新IR的life，更新完后把TCG寄存</span><br><span class="line">     * 器状态配置为dead，对于输出寄存器，必然不会对之前IR的寄存器有依赖。</span><br><span class="line">     */</span><br><span class="line">    for (i = 0; i &lt; nb_oargs; i++) &#123;</span><br><span class="line">        ts = arg_temp(op-&gt;args[i]);</span><br><span class="line"></span><br><span class="line">        op-&gt;output_pref[i] = *la_temp_pref(ts);</span><br><span class="line"></span><br><span class="line">        /* Output args are dead. */</span><br><span class="line">        if (ts-&gt;state &amp; TS_DEAD) &#123;</span><br><span class="line">            arg_life |= DEAD_ARG &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (ts-&gt;state &amp; TS_MEM) &#123;</span><br><span class="line">            arg_life |= SYNC_ARG &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line"> /*</span><br><span class="line">  * 这里对所有输出都配置dead，是因为显然当前这个寄存器在程序运行时不会依</span><br><span class="line">  * 赖前序指令中的这个寄存器。</span><br><span class="line">  */</span><br><span class="line">        ts-&gt;state = TS_DEAD;</span><br><span class="line">        la_reset_pref(ts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 处理TB结束、BB结束、条件跳转以及有side effect的指令。TCG_OPF_BB_EXIT是</span><br><span class="line">     * 离开TB，所以temp dead，global dead和sync。</span><br><span class="line">     */</span><br><span class="line">    if (def-&gt;flags &amp; TCG_OPF_BB_EXIT) &#123;</span><br><span class="line">        la_func_end(s, nb_globals, nb_temps);</span><br><span class="line">    /*</span><br><span class="line">     * 把条件branch指令单拿出来看，条件branch指令只是结束一个BB的一种情况, 结束</span><br><span class="line">     * 一个BB还有goto_tb和exit_tb，开始一个BB还有set_label。     </span><br><span class="line">     *                                                               </span><br><span class="line">     * insn5                         |  BB0                          </span><br><span class="line">     * insn6                         |                               </span><br><span class="line">     * brcond t0, t1, cond, label  --+                               </span><br><span class="line">     * insn1                       --+                               </span><br><span class="line">     * insn2                         |  BB1                          </span><br><span class="line">     * insn3                         |                               </span><br><span class="line">     * insn4     --------------------+                               </span><br><span class="line">     * set_label --------------------+                               </span><br><span class="line">     * insn7                         |  BB2                          </span><br><span class="line">     * insn8                         |                               </span><br><span class="line">     *                                                               </span><br><span class="line">     * 从下到上解析到brcond的时候，所有global和local要sync，但是不一定dead, 普通</span><br><span class="line">     * temp要都dead, 也就是说在程序执行时，后续指令不会再使用temp寄存器，这个和</span><br><span class="line">     * qemu规定的normal temp不能垮BB使用是一致的。对于所有的EBB和const，TCG寄存</span><br><span class="line">     * 器状态不改变。</span><br><span class="line">     */                                                                 </span><br><span class="line">    &#125; else if (def-&gt;flags &amp; TCG_OPF_COND_BRANCH) &#123;</span><br><span class="line">        la_bb_sync(s, nb_globals, nb_temps);</span><br><span class="line">    /*</span><br><span class="line">     * BB_END时，也就是br(直接跳转)、goto_tb、exit_tb以及set_label之前，在上面</span><br><span class="line">     * brcond的基础上EBB/const要dead，fixed要sync。但是原因是？</span><br><span class="line">     */</span><br><span class="line">    &#125; else if (def-&gt;flags &amp; TCG_OPF_BB_END) &#123;</span><br><span class="line">        la_bb_end(s, nb_globals, nb_temps);</span><br><span class="line">    /*</span><br><span class="line">     * 看起来只有ld/store是有effect的指令，根据qemu注释，load/store可能触发异常，</span><br><span class="line">     * global寄存器作为guest CPU的上下文信息，要刷回表示表示guest CPU的内存中。</span><br><span class="line">     */</span><br><span class="line">    &#125; else if (def-&gt;flags &amp; TCG_OPF_SIDE_EFFECTS) &#123;</span><br><span class="line">        la_global_sync(s, nb_globals);</span><br><span class="line">        /* 这里没有搞明白？*/</span><br><span class="line">        if (def-&gt;flags &amp; TCG_OPF_CALL_CLOBBER) &#123;</span><br><span class="line">            la_cross_call(s, nb_temps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 处理输入寄存器状态。对于输入寄存器，如果之前已经dead，对于本条指令，这个</span><br><span class="line">     * 寄存器是dead，因为后面没有人用了，所以配置当前IR的life。但是再往上遍历，</span><br><span class="line">     * 因为这个寄存器在这里使用了，就要激活TCG寄存器，这个就是下面一段代码做的事。</span><br><span class="line">     */</span><br><span class="line">    for (i = nb_oargs; i &lt; nb_oargs + nb_iargs; i++) &#123;                  </span><br><span class="line">        ts = arg_temp(op-&gt;args[i]);                                     </span><br><span class="line">        if (ts-&gt;state &amp; TS_DEAD) &#123;                                      </span><br><span class="line">            arg_life |= DEAD_ARG &lt;&lt; i;                                  </span><br><span class="line">        &#125;                                                               </span><br><span class="line">    &#125;                                                                   </span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 激活输入TCG寄存器。当有一条指令的input用了一个寄存器，那么这个寄存器当然</span><br><span class="line">     * 要live了，这里配置成live，是给产生这个input的指令看的，当后续逆序解析到</span><br><span class="line">     * 这条指令的时候，对应的寄存器就不能是dead。</span><br><span class="line">     */</span><br><span class="line">    for (i = nb_oargs; i &lt; nb_oargs + nb_iargs; i++) &#123;                  </span><br><span class="line">        ts = arg_temp(op-&gt;args[i]);                                     </span><br><span class="line">        if (ts-&gt;state &amp; TS_DEAD) &#123;                                      </span><br><span class="line">            /* 得到可以使用的host寄存器的集合 */</span><br><span class="line">            *la_temp_pref(ts) = tcg_target_available_regs[ts-&gt;type];    </span><br><span class="line">            ts-&gt;state &amp;= ~TS_DEAD;                                      </span><br><span class="line">        &#125;                                                               </span><br><span class="line">    &#125;                                                                   </span><br><span class="line"></span><br><span class="line">    /* todo: 寄存器传递？*/</span><br></pre></td></tr></table></figure>

<p>下面是单独case处理的中间码的相关TCG寄存器的分析，insn_start直接跳过，因为insn_start<br>只是一个hint，discard表示这个指令标记的寄存器后面没有再使用了，所以直接配置对应<br>的TCG寄存器为dead，剩下是call和一堆二输出的中间码。</p>
<p>二输出中间码和对应的单输出的中间码的逻辑是一致的，只不过每个输入输出值是由两个TCG<br>寄存器组成，一个存放低32或64bit，一个存放高32或64bit。二输出的中间码又分为加减和<br>乘法两类，如果两个输出TCG都是dead，对应的IR可以删除，二输出的加减IR，如果只有高位<br>输出寄存器是dead，IR可以转化成单输出加减IR，二输出的乘法IR，输出其中之一是dead时，<br>IR可以分别转化为不同的单输出乘法IR(todo: 没有搞清这里的逻辑)。</p>
<p>call中间码用来支持helper函数，对于没有副作用的函数，如果输出都dead, 就可以删去掉<br>这个call中间码，也就没有对应的helper函数调用了。call的一般处理逻辑和上面的逻辑是<br>基本一致的，从IR的角度看，call可以看成是一条用户自定义的顺序执行的IR，并不会改变<br>BB的划分，另外qemu提供了一组call_flag，程序员可以用call_flag描述helper函数的一些<br>共同特征，比如有没有副作用、有没有对global寄存器的读写等，在处理call相关的寄存器<br>时，qemu根据这些call_flag做寄存器的同步。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">case INDEX_op_call:</span><br><span class="line">  /* 处理没有副作用的情况，这里主要是判断能不能删掉call */</span><br><span class="line">  if (call_flags &amp; TCG_CALL_NO_SIDE_EFFECTS)</span><br><span class="line">      [...]</span><br><span class="line"></span><br><span class="line">  /* 处理输出寄存器和上面的分析基本一致，但是会把op-&gt;output_pref[i]清0 */</span><br><span class="line">  [...]</span><br><span class="line">  op-&gt;output_pref[i] = 0;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * 处理call_flag相关的global寄存器同步，helper函数里有对global寄存器的读写。</span><br><span class="line">   * kill和下面sync的区别是，kill是sync+dead。有对global的写，为啥要dead global? </span><br><span class="line">   * 这里和一个IR的输出是一样的逻辑，被写的global不可能是：在上面一条IR的输出，</span><br><span class="line">   * 然后这里的输入。</span><br><span class="line">   */</span><br><span class="line">  if (!(call_flags &amp; (TCG_CALL_NO_WRITE_GLOBALS | TCG_CALL_NO_READ_GLOBALS)))</span><br><span class="line">      la_global_kill(s, nb_globals);</span><br><span class="line">  /*</span><br><span class="line">   * helper函数里有对全局变量的读。因为helper函数有直接读global(读cpu_env上的变量), </span><br><span class="line">   * 所以调用之前必须把host寄存器上的值刷回内存。qemu这里是全部刷回内存了，其实</span><br><span class="line">   * 是没有必要的，只刷回helper函数里要用的就可以，但是这个信息比较难拿到。所以，</span><br><span class="line">   * 后续的后端翻译，要在call之前，要先处理对应的寄存器，而且其它的IR也要这样。</span><br><span class="line">   */</span><br><span class="line">  else if (!(call_flags &amp; TCG_CALL_NO_READ_GLOBALS))</span><br><span class="line">      la_global_sync(s, nb_globals);</span><br><span class="line"></span><br><span class="line">  /* 这里没有搞懂？*/</span><br><span class="line">  la_cross_call(s, nb_temps);</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">   * 处理输入寄存器和上面的分析基本一致，state_ptr上略有不同，call的输入参数可能</span><br><span class="line">   * 会很多，这里只能对host参数传递寄存器个数范围内的虚拟寄存器指定state_ptr。</span><br><span class="line">   * 另外特殊的地方是，call会直接分配输入寄存器。</span><br><span class="line">   */</span><br><span class="line">  *la_temp_pref(ts) = (i &lt; nb_call_regs ? 0 : tcg_target_available_regs[ts-&gt;type]);</span><br><span class="line">  tcg_regset_set_reg(*la_temp_pref(ts), tcg_target_call_iarg_regs[i]);</span><br></pre></td></tr></table></figure>

<h2 id="后端翻译"><a href="#后端翻译" class="headerlink" title="后端翻译"></a>后端翻译</h2><p> 进入后端翻译的主流程前在tcg_reg_alloc_start函数中先根据TCG寄存器类型(kind)得到<br> TCG寄存器的val_type域段的值，这个域段是一个动态值，指示的是TCG寄存器值对应的存储<br> 状态，比如TEMP_VAL_REG表示当前TCG寄存器的值保存在host寄存器上，TEMP_VAL_MEM表示<br> 当前TCG寄存器的值保存在内存里(cpu_env的TCG寄存器对应域段)，TEMP_VAL_CONST表示常量，<br> TEMP_VAL_DEAD表示一个寄存器不需要从TCG load到host寄存器使用。所以，具体的映射初始<br> 值是：fixed -&gt; TEMP_VAL_REG，global/local temp -&gt; TEMP_VAL_MEM，const -&gt; TEMP_VAL_CONST，<br> normal temp/ebb -&gt; TEMP_VAL_DEAD。</p>
<p> 正序遍历TB的IR链表，逐个翻译每个中间码和TCG寄存器，这个是后端翻译的主流程。可以<br> 看到，这里针对几个特殊的中间码做特殊处理，主流程在tcg_reg_alloc_op里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTAILQ_FOREACH(op, &amp;s-&gt;ops, link) &#123;</span><br><span class="line">    case ...</span><br><span class="line">    default:</span><br><span class="line">        tcg_reg_alloc_op(s, op);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 分配过程会涉及到IR定义里的args_ct域段，这个域段描述IR翻译成特定host指令的限制，<br> 我们先看IR定义里的args_ct如何初始化，明确其中的含义。IR指令的定义在qemu公共代码<br> 里初始化:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* tcg/tcg-common.c */</span><br><span class="line">TCGOpDef tcg_op_defs[] = &#123;</span><br><span class="line">#define DEF(s, oargs, iargs, cargs, flags) \</span><br><span class="line">         &#123; #s, oargs, iargs, cargs, iargs + oargs + cargs, flags &#125;,</span><br><span class="line">#include &quot;tcg/tcg-opc.h&quot;</span><br><span class="line">#undef DEF</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 其中的参数分别是指令名字、输出参数个数、输入参数个数、指令控制参数个数(比如brcond<br> 里的cond)、指令flag(描述指令附加的一些属性)，注意这里只静态定义了每个IR的公共部分，<br> 并没有定义args_ct，args_ct和host指令的特点有关系，所以自然定义在具体host代码里。<br> args_ct初始化的代码路径是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">tcg_context_init</span><br><span class="line">      /* 遍历每个IR，得到host定义的针对每个IR的约束的定义 */</span><br><span class="line">  +-&gt; process_op_defs(s);</span><br><span class="line">        /*</span><br><span class="line">         * 如果host是riscv，tcg_target_op_def就是定义在tcg/riscv/tcg-target.c.inc，</span><br><span class="line">         * 可以看到con_set的值是一个枚举值，对应枚举元素的定义类似：c_o1_i2_r_r_rI</span><br><span class="line">         * 这个枚举类型定义在tcg/tcg.c，枚举元素include host上的具体定义：</span><br><span class="line">         * </span><br><span class="line">         * typedef enum &#123;</span><br><span class="line">         * #include &quot;tcg-target-con-set.h&quot;  &lt;- 如果rv是host，就是tcg/riscv/tcg-target-con-set.h</span><br><span class="line">         * &#125; TCGConstraintSetIndex;</span><br><span class="line">         *</span><br><span class="line">         * 继续从constraint_sets得到这个宏对应的字符串，这里重定义了名字相同的参数</span><br><span class="line">         * 宏，使得名字相同的宏对应的代码不一样：</span><br><span class="line">         * </span><br><span class="line">         * static const TCGTargetOpDef constraint_sets[] = &#123;</span><br><span class="line">         * #include &quot;tcg-target-con-set.h&quot;</span><br><span class="line">         * &#125;;</span><br><span class="line">         *</span><br><span class="line">         * 比如，还是如上的枚举元素，这里得到的tdefs包含一个字符串数组，其中的</span><br><span class="line">         * 每个字符串是：r，r，rI，一个参数可能有多个属性的叠加，比如这里的最后</span><br><span class="line">         * 一个参数就有r和I。</span><br><span class="line">         *</span><br><span class="line">         * 这代码写的也是风骚！具体字符的解析下面分析。</span><br><span class="line">         */</span><br><span class="line">    +-&gt; con_set = tcg_target_op_def(op);</span><br><span class="line">    +-&gt; tdefs = &amp;constraint_sets[con_set];</span><br><span class="line">          /* 解析一个IR中每个输入输出参数的限制，更新到args_ct域段 */</span><br><span class="line">      +-&gt; for (i = 0; i &lt; nb_args; i++) &#123;</span><br><span class="line">              while (*ct_str != &#x27;\0&#x27;) &#123;</span><br><span class="line">              /* 数字的含义没有看懂，似乎表示alias */</span><br><span class="line">              case &#x27;0&#x27; ... &#x27;9&#x27;</span><br><span class="line">              /* 很少用到，是需要分一个新寄存器的意思？*/</span><br><span class="line">              case &#x27;&amp;&#x27;</span><br><span class="line">              /* 表示需要一个常数，但是rv上是i */</span><br><span class="line">              case &#x27;i&#x27;:</span><br><span class="line">              &#125;</span><br><span class="line">              /*</span><br><span class="line">               * 特定host还可以自定寄存器的限制塞到这里，比如，rv在这里塞了如下</span><br><span class="line">               * 的case。从这里也可以看出，args_ct里reg表示寄存器的约束，ct表示</span><br><span class="line">               * 常量的约束。</span><br><span class="line">               *</span><br><span class="line">               * 特定host的约束在host代码里具体定义，比如，下面的ALL_GENERAL_REGS</span><br><span class="line">               * 就定义在tcg/riscv/tcg-target.c.inc，是MAKE_64BIT_MASK(0, 32)</span><br><span class="line">               *</span><br><span class="line">               * qemu里分配寄存器的公共代码的入参中就包含了这里定义的具体约束。</span><br><span class="line">               */</span><br><span class="line">              case &#x27;r&#x27;: def-&gt;args_ct[i].regs |= ALL_GENERAL_REGS; ct_str++; break;</span><br><span class="line">              ...</span><br><span class="line">              case &#x27;I&#x27;: def-&gt;args_ct[i].ct |= TCG_CT_CONST_S12; ct_str++; break;</span><br><span class="line">              ...</span><br><span class="line">          &#125;</span><br><span class="line">          /* 根据特定优先级分配为输出输入参数排序 */</span><br><span class="line">      +-&gt; sort_constraints(def, 0, def-&gt;nb_oargs);</span><br><span class="line">          sort_constraints(def, def-&gt;nb_oargs, def-&gt;nb_iargs);</span><br></pre></td></tr></table></figure>
<p> 单个IR生成host指令以及分配host寄存器的过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">tcg_reg_alloc_op(s, op)</span><br><span class="line">      /*</span><br><span class="line">       * 整个翻到host指令的过程，关键是分配寄存器，在一个TB里分配寄存器，那么就</span><br><span class="line">       * 要有中间变量把分配的和还没有分配的寄存器记录下来。</span><br><span class="line">       *</span><br><span class="line">       * reserved_regs表示被保留起来的host上寄存器，TB块里不能用, 所以这里直接</span><br><span class="line">       * 标记为已分配。</span><br><span class="line">       *</span><br><span class="line">       * 这个函数只是翻译一个IR，几个核心的数据结构的含义是：new_args[]、con_args[]</span><br><span class="line">       * 指的是当前这个IR翻译到host指令时，分配得到的host物理寄存器。s中的reserved_regs、</span><br><span class="line">       * reg_to_temp[]指的是tb翻译上下文host寄存器的分配情况，所以，当一个host</span><br><span class="line">       * 物理寄存器被分配或释放时需要更新s中的reg_to_temp[]对应元素。</span><br><span class="line">       */</span><br><span class="line">  +-&gt; i_allocated_regs = s-&gt;reserved_regs;</span><br><span class="line">      o_allocated_regs = s-&gt;reserved_regs;</span><br><span class="line"></span><br><span class="line">      /* 处理输入参数 */</span><br><span class="line">  +-&gt; for (k = 0; k &lt; nb_iargs; k++) &#123;</span><br><span class="line">      /*</span><br><span class="line">       * 处理输入参数限制, 参数优先级排序还不清楚? 如果是常数，并且根据host</span><br><span class="line">       * 指令可以表示常量的限制，判断是否可以直接把常量编码到指令里，如果可以，</span><br><span class="line">       * 就把信息记录在const_args和new_args，这两者都是后续生成host指令的参数。</span><br><span class="line">       * 如果无法编码到指令里，就要分配寄存器，使用寄存器保存参数，参与计算。</span><br><span class="line">       *</span><br><span class="line">       * 看一个实际的例子，host是riscv时，翻译add_i64这个中间码。add_i64的两个</span><br><span class="line">       * 输入参数，如果后一个参数是立即数，就有可能被翻译成riscv上的addi，否则</span><br><span class="line">       * 就需要翻译成add，但是addi的立即数只有12bit位宽，如果装不下的话，还是需要</span><br><span class="line">       * 把立即数搬到host寄存器上，翻译成add指令。参照如上分析，这个立即数位宽</span><br><span class="line">       * 的限制被生成到add_i64中间码的arg_ct的ct域段，具体在riscv tcg_target_op_def</span><br><span class="line">       * case INDEX_op_add_i64的C_O1_I2(r, r, rI)，rI表示add_i64翻译到riscv上时，</span><br><span class="line">       * 最后一个参数可以被翻译到host寄存器或者立即数编码到指令。当qemu前端翻译</span><br><span class="line">       * 使用add_i64这个中间码并且第二个入参定义成CONST时，如下的代码会得到这个</span><br><span class="line">       * 信息并使用tcg_target_const_match做检测，如果检查成功就做个标记，同时结束</span><br><span class="line">       * 当前寄存器的分配，后面就会根据这个标记生成addi，把第二个虚拟寄存器直接</span><br><span class="line">       * 编码到host指令里。如果检测不成功，就继续分配host物理寄存器，所以可见const</span><br><span class="line">       * 虚拟寄存器可能直接编码到指令或者占用一个host物理寄存器。</span><br><span class="line">       */</span><br><span class="line">      if (ts-&gt;val_type == TEMP_VAL_CONST</span><br><span class="line">          &amp;&amp; tcg_target_const_match(ts-&gt;val, ts-&gt;type, arg_ct-&gt;ct)) &#123;</span><br><span class="line">          const_args[i] = 1;</span><br><span class="line">          new_args[i] = ts-&gt;val;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /* ialias这个没有看懂？*/</span><br><span class="line">      if (arg_ct-&gt;ialias) &#123;&#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       * 给输入参数分配host寄存器，并且从cpu_env中load输入参数到host寄存器，为后</span><br><span class="line">       * 续计算做准备。arg_ct-&gt;regs是host指令在host寄存器分配上的限制。</span><br><span class="line">       *</span><br><span class="line">       * 从这个函数的逻辑就可以看出TCG寄存器val_type的语意，它表示TCG寄存器当前</span><br><span class="line">       * 的存储状态。TEMP_VAL_REG表示已经在host寄存器里，所以直接返回。</span><br><span class="line">       *</span><br><span class="line">       * TEMP_VAL_CONST表示是一个常量(并且当前保存在TCG寄存器)，这里就要分配一个</span><br><span class="line">       * host寄存器，并且生成一条host movi指令把这个常量送到host寄存器上，并且</span><br><span class="line">       * 配置ts-&gt;mem_coherent = 0，这个表示TCG寄存器和host寄存器不同步。</span><br><span class="line">       *</span><br><span class="line">       * TEMP_VAL_MEM表示TCG寄存器的值在内存里，这里要分配host寄存器，并把对应</span><br><span class="line">       * 的值load进host寄存器，同时配置ts-&gt;mem_coherent = 1。从host分配物理寄存器</span><br><span class="line">       * 就会有分不到的情况，遇到这种情况就需要把host寄存器先换到内存，并且标记</span><br><span class="line">       * 这个虚拟寄存器的值在内存上，tcg_reg_free完成这个动作。</span><br><span class="line">       * </span><br><span class="line">       * TEMP_VAL_DEAD表示一个寄存器不需要从TCG load到host寄存器使用。tcg_reg_alloc_start</span><br><span class="line">       * 把TEMP_NORMAL/TEMP_EBB转换成TEMP_VAL_DEAD，像normal temp和ebb这种中间</span><br><span class="line">       * 计算产生的数据，显然始终产生于一个左值，用于存放临时变量(生命周期只在</span><br><span class="line">       * 一个BB内)，不需要刷回内存，更不需要从没存load进host寄存器。</span><br><span class="line">       */</span><br><span class="line">      temp_load(s, ts, arg_ct-&gt;regs, i_allocated_regs, i_preferred_regs);</span><br><span class="line">            /* 如上分析，处理各种val_type的情况 */</span><br><span class="line">        +-&gt; switch (ts-&gt;val_type) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">             * 返回用掉的寄存器，注意这里一定会分到host物理寄存器，没有时也会像</span><br><span class="line">             * 上面说的那样换一个host物理寄存器出来。</span><br><span class="line">             */</span><br><span class="line">        +-&gt; ts-&gt;reg = reg;</span><br><span class="line">            /* TEMP_VAL_REG表示这个虚拟机寄存器的值已经在host寄存器里了 */</span><br><span class="line">        +-&gt; ts-&gt;val_type = TEMP_VAL_REG;</span><br><span class="line">            /* 表示当前物理寄存器对应的虚拟寄存器 */</span><br><span class="line">        +-&gt; s-&gt;reg_to_temp[reg] = ts;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       * 处理dead输入寄存器。上面是考虑如何往出分配host物理寄存器，这里是考虑怎</span><br><span class="line">       * 么回收host物理寄存器。只需要考虑已经dead的寄存器，就是后续不会再用的寄</span><br><span class="line">       * 存器，对于global、local temp，要刷回cpu_env内存，对于normal temp、ebb</span><br><span class="line">       * 只需要dead就好，它们本来就是临时变量。</span><br><span class="line">       *</span><br><span class="line">       * 需要注意的是，temp_free_or_dead这里使用的是dead，也就是对于normal temp</span><br><span class="line">       * 和ebb是dead，另外针对normal temp和ebb的free操作体现在host寄存器不够用的</span><br><span class="line">       * 时候，qemu可以把这些临时变量也换到内存里。(这些临时变量何时销毁？)</span><br><span class="line">       *</span><br><span class="line">       * 这里并没有插入刷到内存的具体操作，只是更新虚拟寄存器的存储状态(val_type)，</span><br><span class="line">       * 以及tb翻译上下文中host物理寄存器的翻译状态(s-&gt;reg_to_temp): 如果当前已</span><br><span class="line">       * 经分配物理寄存器，但是dead了，那么这个物理寄存器就可以给其它虚拟寄存器</span><br><span class="line">       * 用，所以，清理掉reg_to_temp中reg到temp的指向。</span><br><span class="line">       */</span><br><span class="line">  +-&gt; for (i = nb_oargs; i &lt; nb_oargs + nb_iargs; i++) &#123;</span><br><span class="line">        if (IS_DEAD_ARG(i)) &#123;</span><br><span class="line">          temp_dead(s, arg_temp(op-&gt;args[i]));</span><br><span class="line">            temp_free_or_head()</span><br><span class="line">            [...]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">       * 检查条件跳转、BB结尾以及side effect的情况, 处理call_clobber。检查只是做</span><br><span class="line">       * assert，没有逻辑处理。</span><br><span class="line">       */</span><br><span class="line">  +-&gt; if (def-&gt;flags &amp; TCG_OPF_COND_BRANCH)</span><br><span class="line">        [...]</span><br><span class="line">      else if (def-&gt;flags &amp; TCG_OPF_BB_END)</span><br><span class="line">        [...]</span><br><span class="line">      else &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 已经有分支单独处理call，这里就只处理st/ld了，这里会free clobber寄存器,</span><br><span class="line">         * 原因是什么？</span><br><span class="line">         */</span><br><span class="line">        if (def-&gt;flags &amp; TCG_OPF_CALL_CLOBBER)</span><br><span class="line">          [...]</span><br><span class="line">        /* 只是做检查，没有真实sync。确保内存里记录的虚拟寄存器值是对的 */</span><br><span class="line">        if (def-&gt;flags &amp; TCG_OPF_SIDE_EFFECTS)</span><br><span class="line">          [...]</span><br><span class="line"></span><br><span class="line">        /* 处理输出参数 */</span><br><span class="line">  +---&gt; for(k = 0; k &lt; nb_oargs; k++) &#123;</span><br><span class="line">          /* arg_ct这段没有看懂？如下是最后一个分支 */</span><br><span class="line">          reg = tcg_reg_alloc(s, arg_ct-&gt;regs, o_allocated_regs,</span><br><span class="line">                              op-&gt;output_pref[k], ts-&gt;indirect_base);</span><br><span class="line"></span><br><span class="line">          tcg_regset_set_reg(o_allocated_regs, reg);</span><br><span class="line">          /* 没有理解这里？*/</span><br><span class="line">          if (ts-&gt;val_type == TEMP_VAL_REG) &#123;</span><br><span class="line">              s-&gt;reg_to_temp[ts-&gt;reg] = NULL;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          /* 分了一个物理寄存器，所以这个虚拟寄存器的值现在保存在物理寄存器上 */</span><br><span class="line">          ts-&gt;val_type = TEMP_VAL_REG;</span><br><span class="line">          ts-&gt;reg = reg;</span><br><span class="line"></span><br><span class="line">          /* TCG寄存器对应的物理寄存器和内存值当前不一致性 */</span><br><span class="line">          ts-&gt;mem_coherent = 0;</span><br><span class="line">          s-&gt;reg_to_temp[reg] = ts;</span><br><span class="line">          new_args[i] = reg;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /* 根据参数构建指令，各个不同host实现自己的回调 */</span><br><span class="line">  +-&gt; tcg_out_op(s, op-&gt;opc, new_args, const_args);</span><br><span class="line"></span><br><span class="line">      /* 把global输出寄存器刷回cpu_env */</span><br><span class="line">  +-&gt; for(i = 0; i &lt; nb_oargs; i++) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 核心是处理sync，实现寄存器活性分析里已经确定的需要sync的寄存器，TEMP_VAL_REG</span><br><span class="line">         * 即当前值在host寄存器上时，才要刷回内存。为什么TEMP_VAL_CONST有时要先load在store？</span><br><span class="line">         */</span><br><span class="line">        if (NEED_SYNC_ARG(i))</span><br><span class="line">            temp_sync(s, ts, o_allocated_regs, 0, IS_DEAD_ARG(i));</span><br><span class="line"></span><br><span class="line">        /* 处理只dead的输出寄存器，只处理寄存器分配层面的逻辑 */</span><br><span class="line">        else if (IS_DEAD_ARG(i))</span><br><span class="line">            temp_dead(s, ts);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>下面看剩余IR的翻译，主要是mov/call/set_label。</p>
<p>qemu实现set_label的思路是，先把label记录在TCGContext的labels链表里，后端翻译br/brcond<br>时，把跳转指令的地址和labels建立联系，把跳到一个label的跳转指令地址都记录在label<br>的relocs链表里，注意一个label可能从不同的地方跳进来，在tcg_gen_code的结尾处调用<br>tcg_resolve_relocsg更新所有label对应的跳转指令的目的地址。</p>
<p>call其实就是要在TB function上下文里实现helper函数的调用。可以想象qemu的后端翻译<br>要做的有：helper函数入参准备，这个包括入参寄存器不够用的时候，用栈传递函数入参，<br>保存caller save寄存器，跳转到helper函数执行，从栈内恢复caller save寄存器。从qemu<br>具体的实现上看，caller save寄存器并没有被保存到栈上，而至直接刷回了对应cpu_env里，<br>这样只要改变下寄存器存储位置的标识就好，也不需要恢复caller save寄存器。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    赞赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/weixinpay.svg" alt="Sherlock Wang 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/QEMU/" rel="tag"><i class="fa fa-tag"></i> QEMU</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/riscv-AIA%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90/" rel="prev" title="riscv AIA基本逻辑分析">
      <i class="fa fa-chevron-left"></i> riscv AIA基本逻辑分析
    </a></div>
      <div class="post-nav-item">
    <a href="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8meson%E6%9E%84%E5%BB%BA%E7%A8%8B%E5%BA%8F/" rel="next" title="如何使用meson构建程序">
      如何使用meson构建程序 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="wangzhou/blog_comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91"><span class="nav-number">1.</span> <span class="nav-text">基本逻辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E7%A0%81%E4%BC%98%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">中间码优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%B4%BB%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">寄存器活性分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E7%AB%AF%E7%BF%BB%E8%AF%91"><span class="nav-number">4.</span> <span class="nav-text">后端翻译</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sherlock Wang"
      src="/images/yase.svg">
  <p class="site-author-name" itemprop="name">Sherlock Wang</p>
  <div class="site-description" itemprop="description">Linux, kernel, 计算机体系结构</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">214</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">87</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmd6aG91" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wangzhou"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjYXJlY3Jvd19ieXI=" title="我的csdn → https:&#x2F;&#x2F;blog.csdn.net&#x2F;scarecrow_byr"><i class="fab fa-csdn fa-fw"></i>我的csdn</span>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sherlock Wang</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
